<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dafengzai.github.io</id>
    <title>大风仔的博客</title>
    <updated>2021-07-13T16:45:39.820Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dafengzai.github.io"/>
    <link rel="self" href="https://dafengzai.github.io/atom.xml"/>
    <subtitle>Big brother is watching you</subtitle>
    <logo>https://dafengzai.github.io/images/avatar.png</logo>
    <icon>https://dafengzai.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 大风仔的博客</rights>
    <entry>
        <title type="html"><![CDATA[TCP/IP协议中的网络层（概述）]]></title>
        <id>https://dafengzai.github.io/post/tcpip-xie-yi-zhong-de-wang-luo-ceng-gai-shu/</id>
        <link href="https://dafengzai.github.io/post/tcpip-xie-yi-zhong-de-wang-luo-ceng-gai-shu/">
        </link>
        <updated>2021-03-24T16:20:55.000Z</updated>
        <content type="html"><![CDATA[<p>本篇开始关注网路协议中的”网络层“，TCP/IP协议中在网络层中采用标准化的IP协议。网络层的主要任务就是就是通过路由选择算法，为数据报分组通过通信子网选择最合适的路径，将将数据报分组及时送达。</p>
<p>具体来说，网络层的功能有三点：</p>
<ol>
<li><strong>路由选择与分组转发</strong>：通过各种路由算法，为数据报通过通信子网选择最合适的转发路径。</li>
<li>异构网络互联：IP 协议屏蔽了下层物理网络的差异，为上层提供统一的 IP 数据报。</li>
<li>拥塞控制：防止所有节点来不及接收分组而造成大量丢弃的机制。</li>
</ol>
<p>本篇仅作网络层的基本介绍，后续有关路由选择的具体介绍见后续文章。</p>
<h2 id="ip-数据报结构">IP 数据报结构</h2>
<h3 id="ip-报文头">IP 报文头</h3>
<p><strong>IPv4</strong></p>
<pre><code>RFC 971 defines the fields of the IPv4 header on page 11 using the following
diagram: (&quot;Figure 4&quot;)
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |Version|  IHL  |Type of Service|          Total Length         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |         Identification        |Flags|      Fragment Offset    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |  Time to Live |    Protocol   |         Header Checksum       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                       Source Address                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Destination Address                        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Options                    |    Padding    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p>主要关注的几个字段有：</p>
<ul>
<li>总长度：首部+后接的数据部分，单位是字节B</li>
<li>区分服务：指示期望获得哪种类型的服务</li>
<li>生存时间（TTL）：IP分组的保质期。经过一个路由器-1，变成0则丢弃</li>
<li>协议：数据部分的协议</li>
<li>首部检验和：只检验首部</li>
<li>源IP地址和目的IP地址：32位</li>
</ul>
<p><strong>IPv6</strong></p>
<pre><code>RFC2460 section 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |Version| Traffic Class |               Flow Label              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |         Payload Length        |  Next Header  |   Hop Limit   |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                                                               |
    +                         Source Address                        +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                                                               |
    +                      Destination Address                      +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p>值得关注的有：</p>
<ul>
<li>Next Header: Pv6报文是由IPv6标准头+扩展头+负载Payload组成，Next Header字段就指定了扩展头的类型</li>
<li>Payload Length: IPv6 报文头之后的数据长度，单位是字节</li>
<li>Hop Limit: 与IPv4 报文头中的Time to Live类似，每经过一个转发节点减一，为0便丢弃。</li>
<li>128 bit的IPv6地址</li>
</ul>
<h2 id="分组转发">分组转发</h2>
<p>转发（forwarding）一般指网络中的路由器转发IP分组的物理传输过程与数据报转发机制，用于（根据路由表/转发表FIB）决定数据报分组从哪个路径（端口）发送出去。至于如何决定哪些IP地址的报文该从哪个端口进行转发，则是由路由算法进行决定的。</p>
<h2 id="拥塞控制">拥塞控制</h2>
<p>拥塞，在网络中的各个层都会发生。在网络层上，节点来不及接收分组便会发生拥塞。拥塞控制机制主要关心在传输超过网络能够在合理的报文传输延时范围内传输的数据量时发生的情况，是一个网络上的全局性的问题，包含网络中的各个主机与路由器。在网络层上亦有负载均衡/流量调节的机制来防止数据报分组的转发发生拥塞。</p>
<p>值得注意的时，在网络层上的拥塞控制主要关注的是“路径”，在某个链路负载大时通过降低源节点的发送速率（流量调节）或将流量引导到其他链路转发到目标节点（负载均衡），从而保证传送的数据不超过链路的容量。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP/IP协议概览（网络接口层）]]></title>
        <id>https://dafengzai.github.io/post/tcpip-xie-yi-jie-xi/</id>
        <link href="https://dafengzai.github.io/post/tcpip-xie-yi-jie-xi/">
        </link>
        <updated>2020-11-04T15:28:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="总览">总览</h1>
<h2 id="tcpip协议总览">TCP/IP协议总览</h2>
<p>TCP/IP协议主要由：数据链路层、网络层、传输层、应用层这几部分组成。本章主要关注数据链路层</p>
<h1 id="网络接口层">网络接口层</h1>
<p>网络接口层可以初略对应OSI七层模型中的物理层与数据链路层，夹在网络层与下面的物理层之间，主要工作是对网络层到来的IP数据包封装成数据链路层的“数据帧”，并将数据帧通过通信设备（一般为网卡）送入物理层中通过传输介质传输，并对在物理层传输的比特流进行<strong>差错控制与流量控制</strong>，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p>
<h2 id="差错控制">差错控制</h2>
<p>比特流在传输介质中传输时，由于线路本身产生的噪声与外界因素的影响，使得比特流中的某些比特位发生了错误，由1变成0，或由0变成1。或者实在数据帧层面上发生了丢失/重复/乱序。这些错误都会影响链路层向上为网络层提供可靠服务。</p>
<p>对于比特位发生的错误，在数据链路层上的基本原则都是通过冗余编码来对一组二进制比特串进行检错或纠错，即对应着数据链路层的检错编码（常用的例如CRC循环冗余编码）与纠错编码（例如海明编码），显然纠错编码需要的冗余度要大于检错编码，使用哪种编码方式便取决于信道的可靠控制，当信道非常可靠的时候，检错码代价就会小于纠错码。</p>
<p>数据链路层的数据帧尾部的FCS一般就是用于差错控制的比特位。</p>
<h2 id="流量控制">流量控制</h2>
<p>与传输层类似，数据链路层上也有自身的流量控制机制，但区别在于传输层控制的是端到端之间的数据流量，而数据链路层上的流量控制是控制相邻两个节点之间的，仅为了保证接收方节点有足够的缓存空间来接收流量数据。</p>
<p>在数据链路层上的流量控制机制有：</p>
<ol>
<li>停止等待协议：在收到确认后再发送下一个数据帧，简单，但信道利用率低。</li>
<li>滑动窗口协议：有后退N帧协议（GBN）：发送窗口大小＞1，接收窗口大小=1，采用累积确认的方式 /  选择重传协议（SR）：发送窗口大小&gt;1, 接收窗口大小&gt;1，不管乱序，正确接收就返回ack，同时失序帧被缓存。</li>
</ol>
<h2 id="组帧">组帧</h2>
<p>在数据链路层上传输的单位是帧，数据链路层的第一项主要任务就是将网络层送来的IP数据包封装成“帧”，其所能容纳的最大数据长度也叫最大传输单元（MTU）一般默认是1500比特。封装成帧的方式一般就是在一段数据的前后分别添加头部与尾部用于标记（一般为特定比特串，例如01111110(HDLC协议，同时数据内连续5个1后添0)），方便从接收端收到物理层上交的比特流中识别数据帧的开始与结束。<br>
<img src="https://dafengzai.github.io/post-images/1615305313242.png" alt="" loading="lazy"></p>
<p>同时这些数据帧都是在接入了网络的网络适配器（网卡）之间进行传输，而网卡地址（MAC地址）就是数据帧的发送地址和接收地址。有了MAC地址以后，以太网采用广播形式，把数据帧发给所在子网络内所有主机，子网内每台主机在接收到这个包以后，都会读取首部里的目标MAC地址，然后和自己的MAC地址进行对比，如果相同就做下一步处理，如果不同，就丢弃这个包，以此来实现数据帧在相邻节点间的传输。</p>
<p>网络层的基于IP地址的报文转发要在数据链路层上转换为基于MAC地址的数据帧转发，还需要引入一个”ARP“协议来将目标端的IP地址转换为为对应的MAC地址进发送。具体来说就是发送时主机依靠IP-MAC的对应关系/ARP表来封装数据帧，在数据帧头部封装上对应的MAC地址，而二层设备在收到含有目标MAC地址的数据帧后，查看自己的“MAC地址表”，便知道这个MAC地址该从自己的哪个端口发送出去。以此将数据帧送到相应的目标节点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WSL2：Linux下开发的最好入门工具]]></title>
        <id>https://dafengzai.github.io/post/wsl2linux-xia-kai-fa-de-zui-hao-ru-men-gong-ju/</id>
        <link href="https://dafengzai.github.io/post/wsl2linux-xia-kai-fa-de-zui-hao-ru-men-gong-ju/">
        </link>
        <updated>2020-10-20T15:44:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="wsl2介绍你为什么需要他">WSL2介绍：你为什么需要他</h2>
<p>很多人接触编程一开始都是在Windows电脑上使用visual studio开始第一个C语言的程序，但“编程”这一词语包含着许多的意义，在Windows上编写C语言程序只是其中的一部分，当你想见识这广阔的编程学习世界时，就会发现仅在Windows下进行编程有着很大的局限性。</p>
<p>如果你是一名网络工程师，那么Linux下的开发就会是你的一项必备技能，不仅如此，像Java、python、go等语言都能够在Linux下获得很好的开发体验。Linux相比与Windows，除了开源这一无与伦比的巨大优势外，还有着诸如apt包管理工具（让你一步配置好环境）、环境配置方便、开源平台下无数前人帮你踩的坑，造的轮子，这些都会成为你学习路上的巨大助力。</p>
<p>无论你是一时兴起或是学习需要，假设你现在需要在Linux下进行开发。并且你和我一样，不舍得Windows平台下这些方便的图形界面工具，那么你就需要在Windows下进行Linux开发的方法。在Windows下通过终端或开发工具在Linux下开发无外乎这三种方法：</p>
<ol>
<li>租一个Linux服务器，并在之上进行开发。这可以说是最好的方法，如果你条件允许的话我最推荐这一种方法。</li>
<li>Windows下使用虚拟机安装Linux镜像进行开发。首先这其实也是有成本的，使用虚拟机需要你允许在Windows专业版系统之上，且专业的虚拟机软件也是需要收费的。从某种意义上来说WSL2也是一个拥有完整Linux精选的虚拟机，只是我认为他更方便，对用户跟友好而已。</li>
<li>使用WSL2，即Windows subsystem for Linux2，微软在开源领域发力的一大力作，在window10 2004版本起正式启用，无论是专业版还是家庭版的win10，都可以开启这一功能来免费体验Linux下开发的快捷。使用WSL2能够获得接近原生Linux的体验，又能学习Linux命令又能保留Windows下的日常使用的便捷。何乐而不为？</li>
</ol>
<h2 id="wsl2的安装">WSL2的安装</h2>
<p>首先建议各位在Microsoft store上安装WindowsTerminal，Windows下最好的命令行工具。之后要确认本机的Windows系统是否为2004及以上。首先可以在设置—&gt;系统—&gt;关于—&gt;Windows规格处可查看到windows的版本号，只需大于等于2004即可，如果版本号小于2004，可参考<a href="https://www.microsoft.com/zh-cn/software-download/windows10">Windows官网</a>下载官方升级工具来在保存电脑文件的基础上升级到2004版本。</p>
<p>之后建议按照官网的<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">步骤</a>来一步步配置，官网的信息与安装教程时最新最权威的，比啥CSDN博客啥的好多了，建议装个有道词典扩展来辅助阅读网页。</p>
<p>注意：</p>
<ol>
<li>wsl --set-default-version 2 命令处可能会提示内核不是最新版，只需安装提示网站下载最新内核安装即可。</li>
<li>在启动Ubuntu界面时，可能会出现一个错误：<img src="https://dafengzai.github.io/post-images/1603204308746.png" alt="" loading="lazy"></li>
</ol>
<p>这是因为WSL2是基于Hyper-V 运行的，此时只需在BIOS中启用虚拟化即可（我的华硕主板为BIOS—&gt;高级设置—&gt;cpu设置—&gt;启动Intel虚拟化设置）</p>
<h2 id="wsl2下进行开发">WSL2下进行开发</h2>
<h3 id="open-vs-code-in-wsl-2">Open VS Code in WSL 2</h3>
<p>vscode是微软发布的一个文本编辑器，在各路插件的支持下，他已经是一个相当强大的编程工具了，再配合上remote-wsl插件，可以说是WSL2的一个必备伴侣了。</p>
<p>下面我就就建议在Windows下安装好vscode，并下载启用Remote Development来调用WSL2。<br>
<img src="https://dafengzai.github.io/post-images/1603204712394.png" alt="" loading="lazy"><br>
安装完成后点击左下角类似“&gt;&lt;”的图表并选择Remote-WSL，vscode会自动在Ubuntu内安装对应服务。启动后点击顶部的“Terminal”选项，新建一个窗口，就可以通过命令行来操作Ubuntu系统了。</p>
<p>现在，Linux开发的大门已经向你打开了，去拥抱这广阔的世界吧！</p>
]]></content>
    </entry>
</feed>